# SongRandomizer

Hello there, welcome to the start of my journey in creating a small app that will pick a random Python song! This project is the beginning of developing personal projects. As of right now, I am looking to just discover new pieces of music that I may have never otherwise heard, but hopefully I will be able to customize this project even more as I move further along.

For this project, I am developing an application that will involve a React + Vite frontend with a Flask backend for frontend that will make calls to the Spotify Developer API. I will log any prerequesites that someone downloading this repository may need, as well as my progress here!

# DAY 1 (Getting started with Flask and OAuth implementation):
Today I started off by following a tutorial on how to implement OAUTH 2.0 in relation to the Spotify API and pull the Json of my personal playlists to test. Here is the link to that video: https://www.youtube.com/watch?v=olY_2MW4Eik&ab_channel=ImdadCodes

I now feel that I have a basic understanding of OAUTH, and I think that using flask is a great way to start creating a basic user interface without being overwhelmed by all the various facets that come with learning web or app development normally, especially whilst I try learning about how to interact with the API.

While OAUTH may currently not be necessary, I think the tutorial overall provided a great foundation for where I should start with this application. It also gives me the flexiblity to expand capabilities, by implementing more personalized features, in the future should I feel the desire to do so. The tutorial also taught me how to do a basic request for my own playlists, but I am currently only seeing one playlist show up. I wonder if this is because the rest of mine are private, but after making another one public, I have not seen it show up for over 30 minutes now.

Update: From just following the tutorial I realized that my scopes were only 'user-read-private user-read-email', but I also needed to add 'playlist-read-private'. By default, anyone already has access to my public playlists so I do not need to define that in the scope of permissions I am requesting a user grant for the application has access to, but the same cannot be said for private playlists. After adding this scope I can now see ALL of my playlists. As for why changing a private playlist to public did not change anything, I am left to assume that the developer API needs additional time to update.

# DAY 2 (Shifting to a full-stack web application):
It has been over a week since my last commit, but in that time I have considered what I wanted to do with this application and what skills I would like to learn and potentially get out of this. Since then, I wanted to move more towards creating a basic fullstack application, which would involve a React + Vite frontend and Flask backend. As for why I chose React + Vite specifically, this came down to trying to learn a more recent technology, as many developers I have talked to have used React (Meanwhile Vite was thrown in simply because it was used within a guide that suggested it).I would like to work on setting up the environment a little more also, hopefully by eventually learning how to use and then implement Docker for easier testing and deployment. Aside from that though, I am taking this one step at a time and so I have redone the OAUTH implementation such that while the logic remains on Flask, an API call has to be made from the frontend to initiate the login process for users.

# DAY 3 (How does OAuth 2.0 work):
I did not end up committing anything today, but I spent a lot of time researching about what OAUTH 2.0 actually is. In this process I learned about authorization codes, access and refresh tokens, and just the overall sequence of exchanges in this process between a front-end, backend for front-end (BFF), and the OAUTH tenant (Spotify). What prompted me to look into this a bit more simply had to do with the fact that if I wanted other users to eventually use this application - I wanted to make sure that their accounts and data would be relatively safe, even if this application will not be storing any data aside from tokens. I also just had a few doubts and questions in regards to this topic as well.

My two main doubts in regards to the implementation of this included where the access and refresh tokens needed to be stored and handled, as well as how the back-end would be able to handle multiple users accessing the application at the same time: 

- For the first doubt, I understood that the authorization token and client secret required to obtain tokens are both vital components that needed to be well kept, as attackers could misuse these to steal user information and run their own API calls freely. With that in mind, I ultimately came to the conclusion that in the case of my application, the front-end and user's browser did in no way need to access or handle these key pieces directly. Now, this to me was clear cut and obvious for the client secret, but for some reason, along my research path, I had also convinced myself that the access token may need to be stored on the front-end and perhaps this was simply due to confusion from trying to understand the more complex nature of how OAUTH 2.0 works. Of course, there may be use cases for this that I am unaware of, but as I have a BFF that will run all the API calls I need, I feel that this should not concern me for the time being.

- For the second doubt, it stumped me to understand how most applications were able to manage multiple access and refresh tokens coming in from different users, especially at the same time. It seemed that most sources I looked at that were implementing OAUTH 2.0 never seemed to address this, but I did have a lead in that the initial implementation within Flask that I had followed through with from a tutorial did make use of sessions. This prompted me to look into cookies, sessions, as well as session cookies such that I understood how applications could differentiate different users. Of course, there is a lot more to this in that now one may have to think about a system that can provision, manage, and identify session IDs, but thankfully Flask sessions supposedly should already handle all of this, but I hope to personally be able to verify this soon.

Some other things I wanted to address after today were that I acknowledge that there is still a lot of room for potential improvement. My application is still vulnerable to cross site request forgery (CSRF) attacks as I have seen within my research of cookies and sessions, but these attacks will still be limited to whatever API calls I implement, and how long users have their browsers open for. Also I am aware that implementation of proof key for code exchange (PKCE) within OAUTH 2.0 is highly encouraged nowadays, but for the time being I would like to prioritize the implementation of other functionality for the application now whilst also solidifying my understanding of OAUTH 2.0 without PKCE.

I will say that I ran a few circles within my own head trying to achieve some understanding of how this all works, and how I should be implementing this, but I felt that it was important and beneficial to learn. I also enjoyed expanding my knowledge of new concepts, so while it was a slow day in terms of making actual coding progress, I am still satisfied with the outcome.

# DAY 4 (Looking into Docker and containerization):
I have begun looking into Docker files and containerization to automate the process of deploying and running my code for testing and development purposes. Not only will this make my life easier, but it is also good practice for ensuring that code can run on different environments and on different versions of images and dependencies. This will also be useful when it comes time to collaborating with other people on projects in the near future, which I am looking forward to.

On the note of good practice though, I have quickly looked into Virtual Environments (venv) within Python, as many online sources that I have read or referenced often utilize this tool within their own Python projects. As I understand it, venv is used for managing packages within specific Python projects, effectively allowing me to control which packages are installed for specific Python projects I may have locally, separate of whatever packages may already be installed on my system. It may be redundant to do so in this project, given that I will most likely only have one Python application and intend on using Docker as well, but I have decided to try it out tonight just for the sake of developing what I believe to be good organizational habits for software development.

# DAY 5 (Virtual environments for Python):
Building off of using venv from last night, today I have realized that venv only works on a local device. Thus, committing the venv directory to git does not really make sense, as people cloning the repository will run into conflicts and unexpected behaviours trying to use it. I have since removed the venv subdirectory from the repository and added it to the gitignore as a result.

As I have learned, it is important to create the virtual environment before beginning to build a Python application if there is intent to use it, which can be done on Windows by entering the following commmand into the terminal when inside the intended directory:

```
python -m venv venv_directory_name  
```
Once the virtual environment is setup, it can be accessed via the next command within the terminal:
```
venv_directory_name\Scripts\activate
```
From here, I can now proceed to install the necessary dependencies for my Python application and generate a requirements.txt after, which will list all the dependencies installed specifically within the virtual environment by using the command:
```
pip freeze > requirements.txt
```
This requirements.txt file is crucial for ensuring that virtual environments for my other devices, or the devices of collaborators, contain the same dependencies. With this file, the same steps to creating a virtual environment can be followed, but instead of manually installing all the dependencies again, simply utilize the requirements.txt to install all of them with the command:
```
pip install -r requirements.txt
```
Worth noting here is that the requirements.txt file can be committed to the repository making it easier to distribute the same dependencies across multiple devices and their local virtual environments.

# DAY 6 (Playing around with basic Dockerfiles):
I have not spent too much time these last two days on this project but, when I had time, I looked into Docker. Docker and containerization seems to be a bit of a confusing topic to me at the moment, but it is one that I will eventually learn within a course I am currently taking this semester. I also have other resources available from the official documentation to other free online courses, which I am excited to learn from. 

Today I was able to build a basic docker image for the flask backend, and run a container for the image locally, which I was pretty happy with. I tried to do the same for the React + Vite front end but I found myself not being as confident in what I was doing. Aside from just needing to learn more about Docker and containerization, I also felt that I was skipping a few steps here and getting myself into a rabbit hole of learning other things. For example, some online sources that I have been trying to follow use Nginx for their web server, which is a tool that I am completely unfamiliar with. On top of this, when trying to create my dockerfile for the frontend, I had concerns about how Vite might complicate the configurations and this is something that ultimately comes down to me not being knowledgeable enough about the tools that I am using.

There's certainly nothing wrong with learning more, especially about things like Nginx and Vite, but I do feel like progress on this project has been a bit stagnant because I have overwhelmed myself with new things to try and learn. I acknowledge that learning to use these tools, including docker, are absolutely crucial skills to develop within the web development space and will get to learning them eventually, but I also believe that I need to focus on the basics of the application by going back to the functionality and implementation of the frontend and backend. Aside from this, I also realized that given the simplistic structure of my project and the fact that I am the only contributor, there is not really a need to be using docker at the moment, which is another reason why I am putting a hold on learning it for now.

Nontheless, this was all a valuable learning experience as I do have some direction for what I need to be doing, but also an idea of some subjects to study up on in the future.

# DAY 7 (Front-end responsive to login):
Back on track with working on the functionality of the application, today I needed to figure out a way to have the frontend respond to a successful login by the user. Initially I thought that I might be able to somehow utilize cookies sent from the backend but, for security reasons, the cookies are set to HTTPS only such that JavaScript code does not have access to them. Then I thought about URL parameters, and this seemed to work as I could simply input a true or false value within the redirect URL back to the frontend page if they had authenticated successfully into Spotify. With some conditional rendering, the frontend now renders differently once the user has logged in. I did have some concerns with my method here though as a user could just manually set this parameter to true within their own browser search bar, but for the time being I believe that it should be okay simply because I intend to have API calls to the backend called upon the rendering of this "logged in page". With these API calls, the backend will immediately know whether or not the user is actually logged in, and if not, this will force the parameter's value to false thus sending them back to the login page on the frontend.

While I am satisfied with the results of today, looking more into flask sessions has left me wondering if I am using the correct library for it on the backend. As I understand it, there are two sessions libraries that can be imported and the one I am currently using seems to be less capable. Of course, I am not entirely concerned about this, and as long as it gets what I need done in a secure manner I am perfectly happy to continue using it. Thus, only time will tell whether the current library can fulfill my requirements, as my biggest concern was whether sessions could actually differentiate between different users and store all of these unique access and refresh tokens, which I will look into testing with multiple browsers and Spotify accounts once I finish setting up the application to be able to clearly demonstrate whether or not this is working. If this current implementation does not work, then I may have to look into implementing a database on the backend for storing all these tokens, as this is necessary for working with the other sessions library.

# DAY 8 (Display currently playing song):
Today I worked on a mock API call between the frontend to the backend after the user has logged in. For this, I implemented an API call to retrieve the current song being played by the user and this was overall fairly straightforward. Spotify provides some clear documentation, and it seems that for the most part, once you are able to make one API call, the rest are mostly the same. The most time consuming aspect of this implementation was understanding how data is received by the backend, and how to format it in a way that is easy for the frontend to handle and display, but a lot of this just comes down to understanding how Json data is or needs to be formatted. Now this ended up being successful as I was able to display the track that is currently playing on the frontend and overall I think this would be a convienent feature to have, but there are hurdles. 

Addressing the hurdles, I first would need to do some error handling with the API such that if no song is playing - it displays that, because otherwise it will throw errors and nothing on the frontend will render. Additionally, I think it's important for this to be updated in real time if I do end up implementing this feature, but there is no way for Spotify to notify my backend everytime a new song begins or the current one ends. As a result, I am left thinking about how I can get the most accurate display of the current song most efficiently, since constant API calls would be quite inefficient I believe, especially if multiple users were connecting to the same backend server. This is a hurdle that I will continue to think about in the back of my head, but I am still satisfied with what I have accomplished today, even if it was the implementation of a minor feature.

# DAY 9 (Display a playlist name and UseEffect learning):
I had taken a break over the weekend from working on this project so it has been a few days since I last worked on it. Thinking about the functionality of this web application, there were two main functions I wanted to implement intially. The first was a song randomizer that in some way plays a random song on the user's Spotify client. This is proving to be more difficult as there is no clear way or immediate API that can enable me to pull from Spotify's database of music and select a song at random. I did try exploring some methods, such as by potentially retrieving a list of all categories, from the categories API, but unfortunately the APIs that used to allow song browsing by categories have been deprecated. Additionally, I could also pull a list of recommended music or playlists and pull a song from this pool, but I really wanted this functionality to be about getting thrown random music that I would never have come across in a million years. For the time being I would like to put this functionality on the side, while I think about some ways to implement some sort of work around that I am satisfied with.

As for the second main functionality I wanted to implement, this was a proper playlist shuffle. I have heard many complaints from friends and family, as well as seen many online, about the built-in shuffle function for Spotify playlists not being the greatest. I personally agree with this, and I think the major issue is that on consecutive shuffles of the same playlist - a lot of the same songs somehow end up at the top of the queue everytime. My guess for why this is happening is because Spotify in some way has gathered what it thinks are my favourite or most played songs or types of songs, and it attempts to cater to that, but this really is not what a shuffle feature is for or about. If I have already created a playlist of songs, odds are that I like all the songs in it already, and I really do not want to hear the same songs on repeat sometimes. With that said, that leads into what I have implemented today. I have managed to retrieve a list of all my playlists, and successfully send it to the frontend, via API calls, to display the name of one of the playlists.

Displaying the name of a single playlist acutally took a bit longer than I anticipated, and this has to do with the fact that my API call from the frontend to the backend for retrieving playlists was done inside a useEffect hook. My initial understanding was that any function inside of the useEffect hook would be executed upon the rendering of a page, and this is true. The only problem is that this execution occurs after an inital render of the page has already happened, and this is what was causing me issues. I had wanted to simply render one name of a playlist from a list of playlists that needed to first be retrieved via an API call, and so errors would show up because I was trying to retrieve this name attribute from an empty array that had not yet been updated with a Json of all the playlists. Eventually I did figure this out though, and while it was a little frustrating to figure out what was going wrong, this was a very insightful learning for me. To remedy this, I now check if the array is empty first, as that is what it is initialized to, and if it is empty I will display "loading" instead of the name of the playlist until the API call response is received and that specific component can then automatically be rerendered.

# DAY 10 (Display all playlists, cleaning up fetches, and reworking Redirects):
Building off of yesterday's progress, I first started by working on displaying all of my playlists on the the frontend and this was fairly straightforward. I was able to use the map function to easily do this within an unordered list, and also add a mock 'Shuffle' button to every playlist. While I was adding an empty handle function for the onClick of this button, I was reminded that I cannot actually put a function call inside of onClicks or else they will cause an execution loop as they will always be executed on a render or re-render of the button. Thus, for those instances where you need to input values to the function, it is important to put it into an arrow function first.

After working on the display of playlists, I wanted to begin working on the functionality of the 'Shuffle' button, and so I went to brush up on my knowledge of Fetch. In the process of doing this, I learned about the chain of promises, which was not really different from what I was already doing. Instead of using async functions and the await keyword, a chain of .then() statements or promises can be used instead. I believe functionally they work the same, but I personally found that the chain of promises looked cleaner in my opinion, although it could be argued that using an async function with await is more readable. As a result, I ended up rewriting all the Fetch statements to use a chain of promises instead, and hopefully I will be able to use this to send POST requests with specific playlists to the backend next.

On another note, today I got home and wanted to work on this project from my home desktop, but it seems as though the cookies had been lost on my browser, but this is when I realized that the application was not redirecting me back to the login page automatically. It was at this moment that I realized that I had only redirected the backend server to the backend login page, which does not do anything other than return a link to the Spotify OAuth page. Thus, I implemented the following logic of: if no access or refresh token is in session, redirect to the frontend login page. This, however, does not work because this still only redirects the backend server and not the browser of the user, and top of that the frontend is still expecting a properly formatted response to it's API calls. So, to workaround all of this, I ultimately came to the idea that the backend needed to return a Json object with a specific redirect field that the frontend can then use to determine whether it needs to render the login or loggedin page by itself. This ended up working out as the page now redirects itself to the login page if the backend detects that there is no access or refresh token.

In this process of making sure everything worked properly, I ended up going over the behaviour of useEffect again. While I had forgotten, useEffect in this case will only ever run upon the inital rendering of the entire page, and not on any rerendering of specific components, unless the dependencies array is populated. Thus, if I have states that I want useEffect to react to, I can add these states to the dependency array.

# DAY 11 (Refreshing tokens):
I ran into a similar issue today where when I returned to working on my laptop the 'logged in' page failed to render. This time, I confirmed that my browser had retained the cookies from yesterday, so I was able to quickly surmise that it was an issue with refreshing the tokens. When I manually went to the refresh route on the backend, the token was able to refresh correctly, so it was something wrong with the way that I was attempting to call or redirect to the refresh token API. Upon diving deeper into my code, it became apparent that I was trying to return a redirect to the refresh token API to the frontend, in the event that the frontend had called a different API call, and the API discovered that the access token had expired. While I won't get into the full details of how my original code was wrong and how I fixed it there were some learnings to be had in this.

For starters, I ended up learning today that redirects have to be called within return statements. While I was trying to resolve this issue, I attempted to just redirect amidst an API call but this essentially does nothing. Aside from this, I also learned another behavioural aspect about the useEffect hook in React. While I was reminded about the dependencies array for useEffect yesterday, today as I tried to use it, I found that it initially was not working. This ended up having to do with the fact that if I include a state inside this dependency array, useEffect will only execute again if updating the state actually directly impacts the re-rendering of a component on the page, which it did not at first. While I am sure that there is a better solution for figuring out how to refresh tokens when the backend detects that the access token has expired, my current solution works fine now, and maybe I will revisit this again in the future to clean it up further.

# DAY 12 (Update):
I have not had time to work on this project in a little while just because of focusing on schoolwork. With that said, there are a few things that I need to do to get back on track and so I thought I would log it here as a reminder. Firstly, building upon last time, I realized that there was one major flaw in my implementation of refreshing tokens. As I have it setup now, refreshing a token works only because my frontend is checking if a token needs to be refreshed upon an initial rendering of the page, with the help of the useEffect hook. I realized that if I am to make further API calls which do not occur upon the immediate rendering of the logged in page that it will not check if tokens need to be refreshed in this instance, so I will have to think about how to change this. Additionally, Spotify has recently announced the deprecation of implicit grant for OAuth, so this means that public facing applications will have to implement OAuth with PKCE now. On top of this unsafe redirect URIs are no longer being supported, but this is something I have yet to fully understand.

# DAY 13 (ASCII, Unicode, UTF-8, Base64 and encodings):
Today I began working on getting OAuth with PKCE implemented. Luckily, Spotify already provides some JavaScript code which I can base my implementation off of. So far, I have only looked into the code verifier for this process, which to my understanding is a uniquely generated code, which can contain uppercase and lowercase letters, as well as digits in a random sequence of length 43-128. 

While working on generating this code verifier, I ran into an intersting issue, which was that the randomly generated string could not be hashed using SHA256 without being encoded into UTF-8 first, and this had me curious to know what all of this was about.

As I currently understand it, when I create a string in Python, this is stored as Unicode. Now unicode is actually just an abstract representation of every possible character or symbol that a computer can output using decimal numbers. There is a limit to this as Unicode can only represent up to 65535 characters, but as computers only work in binary fundamentally, these decimal representations are always converted to binary when being stored within a computer. Similarly, ASCII is also just another abstract representation of possible characters and symbols except that it is much more limited, mainly to just the English alphabet. In fact, ASCII actually came before Unicode, but Unicode is really just a large extension of ASCII, such that it is backwards compatible with ASCII.

What is really interesting here though is that Python actually already encodes unicode using UTF-8. UTF actually stands for unicode transformation format. This really confused me because when Python is storing a binary representation of unicode, it is by default storing a UTF-8 encoding of the unicode in memory. This, however, does not mean that you never have to encode strings into UTF-8. Just because of the way that Python works, it actually makes a distinction between strings and bytes. As hashing is an operation that involves bytes, you actually cannot hash strings directly, even though I felt that you should be able to given the default UTF-8 encoding. Instead, you must explicitly encode a string in UTF-8 first within source code, and hash this binary encoding.

In terms of what all of this actually is, ASCII and Unicode are both not encodings. As mentioned previously, they are abstract representations of characters. Meanwhile, there exists UTF-8, UTF-16 and so forth, but these are all encodings of Unicode, as implied by the "U" in UTF. The only difference between each being how many bits are used to store a character. There also exists base64 encoding as well, which is also a part of the code verifier implementation, and to my knowledge if UTF is an encoding of Unicode/ASCII to binary, base64 is an encoding of binary/bytes to a set of 64 ASCII characters. Worth noting also is that base64 is not a decoding of UTF. If a string is encoded into bytes, and then those bytes are once again encoded using base64, you should not expect to get the original string back.

# DAY 14 (PKCE and redirect URIs):
Talking about how the flow works, it appears that the client, first generates a random string code verifier and then hashes this with SHA 256, before sending what is the code challenge to the Spotify server. Then when the client requests for the access and refresh tokens using the authorization code it receives, it must then send the initially generated code verifier, as proof that it is the original requester. What makes this safer than a client secret is that this code challenge and verifier is always different between sessions and for all users. Generally, a client secret has to be kept secret between the client and server so that attackers cannot easily make requests while impersonating users to the authorization server, so having what is essentially an everchanging client secret makes this a lot more difficult.

This, however as I have come to fully understand does not actually impact my application. For applications that do store the client secret safely, it is still recommended to implement the traditional OAuth 2.0 method over implementing PKCE according to Spotify. I did actually end up implementing PKCE in my confusion, but I am correcting this now. I was actually entirely unaware of the existence of implicit grant, but PKCE is definitely much safer.

Talking about redirect URIs though, for some reason Spotify is mandating that loopback addresses like 127.0.0.1 be used over localhost. I personally thought these were the same, but I will have to look into this further given these changes. I tried to adjust my application so that 127.0.0.1 is used for the redirect instead, but this seems to cause issues with my sessions.
